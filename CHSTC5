//*******************************************************
//* 
//* Author:  Automatically generated by Perfect Developer
//* Created: 09:40:25 on Friday October 8th 2010 UTC
//*******************************************************
//////////////////////////////////////////////////////////////////////////
//  Gabarit - GLO-3004, spécification formelle et vérification, 
//////////////////////////////////////////////////////////////////////////

//-- Types de base (abstraits) -------------------------------------------
// L'énoncé n'indique aucune information concernant les attributs d'un
//il est alors normal de les considérer comme des types abstraits "tag".
// Les quantités sont naturellement des entiers naturelles. 

class Produit ^= tag;
class Quantite ^= nat;
  



// 


//-- Constantes ----------------------------------------------------------
//  La capacité de stockage est une constante liée aux installations de l'entreprise. 

const 

 //CHSTC5 debut
 minSatisfaction : nat ^= 1,
 maxSatisfaction : nat ^= 10,
 satisfactionSeuil : nat ^= 3,
 renouvellementSeuil : nat ^= 150,
 //CHSTC5 fin
 
 capacite : nat ^= 1000;
 







//------------------------------------------------------------------------
// CLASSE Gestiontock
//------------------------------------------------------------------------
// L'énoncé indique clairement plusieurs attributs et propriétés relatifs
// à la gestion de  stock, il est donc normal d'y associer une classe.	
//--------------------------------------------------------------------------

class GestionStock ^= 

abstract 

var 

// Le stock est une association (produit, quantite)
// Le marcheCible est un ensemble de produits.
// Les seuils sont fournis comme une association (produit,seuil)

 //CHSTC5 debut
 produitsPopulaires		: set of (Produit),
 produitsNonPopulaires	: set of (Produit),
 satisfaction	: map of (Produit -> nat),
 fermeture		: bool,
 //CHSTC5 fin
 
  stock          : map of (Produit  -> Quantite),
  marcheCible    : set of (Produit),
  seuil          : map of (Produit -> Quantite),
  renouvellement : map of (Produit -> nat);
  
  
  
invariant

// Les produits en stock doivent faire partie du marche cibe. 
// Le domaine de seuil est le même que le domaine de stock,
// à chaque produit en stock on associe un seuil. 
// Un renouvellement est associé à chacun des produits en stock.
// La quantité de chacun des produits ne doit pas dépasser la capacité de stockage fixée d'avance
// Les seuils ne doivent pas être plus élevés que la capacité de stockage (déduction logique!)
// La quantité en stock de chaque produit doit être supérieur ou égal au seuil minimal associé 
// au produit et inférieure ou égal à la capacité.

  //CHSTC5 debut
  //Verifier la validité des constantes fournies.
  minSatisfaction <= maxSatisfaction,
  satisfactionSeuil <= maxSatisfaction,
  satisfactionSeuil >= minSatisfaction,
  renouvellementSeuil <= capacite,
  capacite >= 0,
  renouvellementSeuil >= 0,
  
  //Chaque satisfaction associé à un produit doit respecter les limites de satisfaction.
  satisfaction.dom = stock.dom,
  forall p::satisfaction.dom :- satisfaction[p] <= maxSatisfaction,
  forall p::satisfaction.dom :- satisfaction[p] >= minSatisfaction,
  
  produitsPopulaires <<= stock.dom,
  produitsNonPopulaires <<= stock.dom,
  (produitsPopulaires ** produitsNonPopulaires).empty, //Disjoint
  produitsPopulaires ++ produitsNonPopulaires = stock.dom, //Union représente les stocks
  
  //TODO : valider formulation
  (
  [(stock.dom).empty]: fermeture = true,
  []: fermeture = false
  ),
  //CHSTC5 fin	
  
     stock.dom <<= marcheCible, 
     seuil.dom =  stock.dom,
     renouvellement.dom = stock.dom,
     forall p::stock.dom :- stock[p] <= capacite,
     forall p::seuil.dom :-  seuil[p] <= capacite,
     forall p::stock.dom :- seuil[p]<= stock[p];
  

   
  
interface

// Puisqu'on passe des paramètres lors de l'initialisation. Il faut s'assurer 
// qu'ils sont conformes aux invariants. 

build{!stock: map of (Produit -> Quantite), !marcheCible :set of (Produit), !seuil:map of (Produit -> Quantite)}

pre
	//CHSTC5 debut
	produitsPopulaires = stock.dom,
	//CHSTC5 fin
	
    stock.dom <<= marcheCible,
    seuil.dom =  stock.dom,
    forall p::stock.dom :- stock[p] <= capacite,
    forall p::seuil.dom :-  seuil[p] <= capacite,
    forall p::stock.dom :-  seuil[p] <= stock[p]
     

post
	//CHSTC5 debut
  //TODO : valider formulation
  (
  [(stock.dom).empty]: fermeture = true,
  []: fermeture = false
  ),
  satisfaction! = map of (Produit -> nat) {for p ::stock.dom yield pair of (Produit, nat) {p, minSatisfaction}};
  //CHSTC5 fin
renouvellement!  =  map of (Produit -> nat) {for p ::stock.dom yield pair of (Produit, nat){p,0}}; 

  





schema !achatProduitExistant(p:Produit,q:Quantite)

// Pour pouvoir acheter une quantité q d'un produit existant, 
// Il faut s'assurer que le produit est en stock
// il faut s'assurer que  le total de la quantité existante plus celle qu'on achète reste 
// inférieure ou égale à la capacité

pre 
  //CHSTC5 debut
  fermeture = false,
  //CHSTC5 fin
  p in stock.dom,
  stock[p]+q <= capacite

post 
   stock! = (stock.remove(p)).append(p -> stock[p]+q),
   renouvellement! = (renouvellement.remove(p)).append(p -> renouvellement[p]+q);


                                                    
schema !achatNouveauProduit(p:Produit,q:Quantite,s:Quantite)

// Il faut s'assurer que le produit fait partie du marché cible   
// Pour pouvoir acheter une quantité q d'un produit p non existant en stock, 
// Il faut fournir le seuil  minimal  et il faut s'assurer 
// qu'il est inférieur ou égal à la capacité                                                               
// il faut s'assurer que la quantité  qu'on achète est    
// inférieure ou égale à la capacité et supérieure ou égal au seuil 

                                                                                          
pre 
  //CHSTC5 debut
  fermeture = false,
  //CHSTC5 fin                                                                                            
  p ~in stock.dom,
  p in marcheCible,
  q <= capacite, 
  s <= capacite,
  s <= q

post
   stock! = stock.append(p -> q),
   seuil! = seuil.append(p -> s),
   renouvellement! = renouvellement.append(p -> 0);



   
schema !venteProduit(p:Produit,q:Quantite)

// Il faut s'assurer que le produit fait partie du stock  
// Pour pouvoir vendre une quantité q d'un produit p existant en stock, 
// Il faut que q soit inférieure ou égale à la capacité 
// Il faut s'assurer que la quantité qui resterait aprés la vente soit supérieure ou égal au seuil                                                         

pre 
  //CHSTC5 debut
  fermeture = false,
  //CHSTC5 fin
  p in stock.dom,
  q <= capacite,
  seuil[p] <= stock[p]-q

post 
	//CHSTC5 debut
	(
	[(seuil[p]) = 0 && ((stock[p]) - q) = 0]: retirerStock(p),
	[]: stock! = (stock.remove(p)).append(p -> (stock[p]-q))
	);
	
	//CHSTC5 fin
   //stock! = (stock.remove(p)).append(p -> (stock[p]-q));    //CHSTC mod
   


schema !venteProduitAchat(p:Produit,q:Quantite)

// Il faut s'assurer que le produit fait partie du stock  
// Pour pouvoir vendre une quantité q  qui fait baisser le stock en deçà du seuil
// Il faut s'assurer que la quantité q vendue soit inférieure ou éagle à capacité mois le seuil minimale
// Il faut commencer par acheter le maximum possible (capacité - stock[p]) puis vendre q. 

    
pre 
  //CHSTC5 debut
  fermeture = false,
  //CHSTC5 fin
  p in stock.dom,
  stock[p]-q < seuil[p],
  q <= capacite-seuil[p]
 

post 
    !achatProduitExistant(p,(capacite-stock[p])) then !venteProduit(p,q);
    
//CHSTC5 debut
schema !retirerStock(p:Produit)
pre
	fermeture = false,
post
	stock! = (stock.remove(p));
	(
	[stock.empty]: fermeture = true,
	[]: fermeture = false
	)
	
schema !retirerProduit(p:Produit)
pre 
  p ~in stock.dom,
  p in marcheCible,
  #(marcheCible) >= 2
post
	//TODO : retirer item marcheCible
	;
	
	
schema !sondagePopulaires()
pre
	fermeture = false,
	
post
	produitsNonPopulaires! = (those p::renouvellement.dom :- renouvellement[p] < renouvellementSeuil),
	produitsPopulaires! = produitsNonPopulaires ** stock.dom,
	
	( 
	[produitsNonPopulaires ** (those p::satisfaction.dom :- satisfaction[p] < satisfactionSeuil)]:
			seuil! = (seuil.remove(p)).append(p -> 0)
	)
;
//CHSTC5 fin   
    
schema produitsPopulaires(pp!: set of (Produit),q:Quantite)
 

// Il faut récupérer les produits dont le renouvellement est supérieur ou égal à q


post 
     pp! = (those p::renouvellement.dom :- renouvellement[p] >= q)   
    
end;	

// End
